_cdb_completion()
{
    #if [[ ${COMP_CWORD} -gt 1 ]]; then COMPREPLY=(); return 0; exit; fi

    opts=$(find  ~/.cd_bookmarks/ -type l -printf "%f ")
    cur="${COMP_WORDS[COMP_CWORD]}"

    COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )

    return 0
}

complete -F _cdb_completion "cdb"

function cdb() {
    USAGE="Usage: cdb [-c|-g|-d|-l] [bookmark]" ;
    if  [ ! -e ~/.cd_bookmarks ] ; then
        mkdir ~/.cd_bookmarks
    fi

    if [ -z "$1" ] ; then
        ll ~/.cd_bookmarks/
        return
    fi

    local UPDATE_CODE="wget -O ~/.cdb https://raw.githubusercontent.com/crazzywak/stuff/master/.cdb && source ~/.cdb"

    case $1 in
	-p) echo $UPDATE_CODE
	    ;;
        # update script
        -u) eval $UPDATE_CODE
            ;;
        # create bookmark
        -c) shift
            if [ ! -L ~/.cd_bookmarks/$1 ] ; then
                local current_dir=$(pwd)
                if [ ! -z "$2" ]; then current_dir=$(readlink -f $2); fi
                local bookmark_name=$1
                echo "Creating bookmark for '$current_dir' with name '$bookmark_name'..."
                ln -s $current_dir ~/.cd_bookmarks/$1 ;
            else
                echo "Looks like there is already a bookmark '$1'"
            fi
            ;;
        # delete bookmark
        -d) shift
            if [ -L ~/.cd_bookmarks/$1 ] ; then 
                rm ~/.cd_bookmarks/$1 ;
            else
                echo "Bookmark $1 doesn't exist." ;
            fi    
            ;;
        -e) shift
            local output="CDBOOKMARKS\n"
            for f in ~/.cd_bookmarks/*
            do
                output+="$(basename $f),$(readlink $f)\n"
            done
            printf "${output}\n"
            printf "$output" | gzip | base64 -w0
            printf "\n"
            ;;
        -g) readlink -f ~/.cd_bookmarks/$2
            ;;
        -if) FORCE_IMPORT=1
            ;&
        -i) shift
            firstLine=1
            lines=$(echo "$1" | base64 -d | gunzip)
            printf "$lines\n\n"
            read -p "Import? " -n 1 -r
            echo
            if ! [[ $REPLY =~ ^[Yy]$ ]]; then return; fi
            
            for p in $lines
            do
                if [ $firstLine -eq 1 ]; then
                    if [ $p != "CDBOOKMARKS" ]; then
                        echo "Not a bookmarks file."
                        return
                    fi

                    firstLine=0
                    continue
                fi

                var1=$(echo $p | cut -f1 -d,)
                var2=$(echo $p | cut -f2 -d,)
                if [ -z "$FORCE_IMPORT" ] && [ -e ~/.cd_bookmarks/$var1 ]; then
                    echo "Bookmark $var1 already exists."
                else
                    echo "Importing $var1... "
                    ln -sf $var2 ~/.cd_bookmarks/$var1
                fi
            done
            ;;
        # help
        -?) echo "$USAGE" ;
            ;;
        # goto bookmark
        *) if [ -e ~/.cd_bookmarks/$1 ] ; then 
                real_path=$(readlink -f ~/.cd_bookmarks/$1);
                if [ ! -z "$2" ]; then
                    $2 $real_path
                else
                    if [ -d $real_path ]; then
                        cd $real_path
                    else
                        vim $real_path
                    fi
                fi
            else
                echo "Bookmark $1 doesn't exist." ;
            fi
            ;;
    esac
}


function yacopy()
{
    local result;
    local yn;

    for x in "${@:2}"
    do
        FILES=$(find $1 -name $(basename $x))
        echo "Copying $x"
        for matchedFile in $FILES
        do
            result="bad"
            while [ $result == "bad" ];
            do
                read -p "Replace $matchedFile? (y/n/s)" yn
                case $yn in
                    [Yy]* ) result="yes";;
                    [Nn]* ) result="no";;
                    [Ss]* ) result="skip";;
                    * ) result="bad";;
                esac
            done

            [ $result == "yes" ] && cp -f $x $matchedFile
            [ $result != "no" ] && break
        done

        if [ -z "$FILES" ]; then
            echo "File not found."
        elif [ $result == "no" ]; then
            echo "Skipped $x because all target files have been tried."
        fi
    done
}

foreachdir() {
        for x in "${@:2}"
        do
                if pushd $x &> /dev/null
                then
                        echo "$(tput setaf 2)-----------------------------------------> $x $(tput sgr 0)"
                        $1
                        popd &> /dev/null
                fi
        done
}
